# Brainfuck 解譯器與編譯器

一個功能完整的 Brainfuck 工具集，包含解譯器和 x86 編譯器，能夠執行或編譯標準的 Brainfuck 程式。

## 功能特色

- ✅ **Brainfuck 解譯器** - 直接執行 Brainfuck 程式
- ✅ **x86 編譯器** - 將 Brainfuck 編譯為原生 x86 機器碼
- ✅ **高效能** - 編譯版本比解譯版本快 **4-10 倍**
- ✅ **系統調用** - 編譯器使用 Linux 系統調用，不依賴 C 標準庫
- ✅ **30,000 記憶體單元** - 符合 Brainfuck 標準規範

## 簡介

Brainfuck 是一種極簡主義的程式語言，只包含 8 個指令：
- `>` - 指標向右移動
- `<` - 指標向左移動
- `+` - 當前記憶體單元值加 1
- `-` - 當前記憶體單元值減 1
- `.` - 輸出當前記憶體單元的值（ASCII 字元）
- `,` - 從輸入讀取一個字元到當前記憶體單元
- `[` - 如果當前記憶體單元值為 0，跳轉到對應的 `]` 之後
- `]` - 如果當前記憶體單元值不為 0，跳轉回對應的 `[` 之後

本解譯器提供 30,000 個記憶體單元（8 位元無符號整數），支援完整的 Brainfuck 語法。

## 編譯與執行

### 方式 1：使用解譯器（簡單快速）

#### 編譯解譯器
```bash
gcc main.c -o bf
```

#### 執行
```bash
./bf hello.bf
```

輸出：
```
Hello World!
```

**優點**：簡單、快速啟動
**缺點**：執行速度較慢

---

### 方式 2：使用編譯器（高效能）⚡

#### 1. 編譯 Brainfuck 編譯器
```bash
gcc -o compiler_x86 compiler_x86.c
```

#### 2. 將 Brainfuck 程式編譯為組語
```bash
./compiler_x86 hello.bf > hello.s
```

#### 3. 組譯為可執行文件
```bash
gcc -m32 -nostdlib -no-pie -o hello-x86 hello.s
```

#### 4. 執行編譯後的程式
```bash
./hello-x86
```

輸出：
```
Hello World!
```

**優點**：執行速度快 4-10 倍
**缺點**：需要額外的編譯步驟

---

## 性能比較

| 程式 | 解譯器 | 編譯器 | 速度提升 |
|------|--------|--------|----------|
| hello.bf | 0.005s | 0.002s | **2.5x** |
| mandelbrot.b | >10s | 2.5s | **>4x** |

編譯器將 Brainfuck 指令直接轉換為 x86 機器碼，無需運行時解析，因此執行效率遠高於解譯器。

## 檔案結構

### 解譯器
- `main.c` - Brainfuck 解譯器核心邏輯
- `bf` - 編譯後的解譯器執行檔

### 編譯器
- `compiler_x86.c` - x86 (32-bit) Brainfuck 編譯器
- `compiler_x86` - 編譯後的編譯器執行檔

### 工具與範例
- `util.h` - 工具函數（檔案讀取、錯誤處理、堆疊結構）
- `hello.bf` - Hello World 範例程式
- `mandelbrot.b` - 曼德博集合分形圖範例（複雜程式）
- `hanoi.b` - 河內塔解題程式範例

## 技術細節

### 編譯器實作原理

**compiler_x86.c** 將 Brainfuck 程式轉換為 x86-32 組合語言：

| Brainfuck | x86 組語 | 說明 |
|-----------|---------|------|
| `>` | `incl %ecx` | 指標遞增 |
| `<` | `decl %ecx` | 指標遞減 |
| `+` | `incb (%ecx)` | 記憶體值遞增 |
| `-` | `decb (%ecx)` | 記憶體值遞減 |
| `.` | `int $0x80` (sys_write) | 輸出字元 |
| `,` | `int $0x80` (sys_read) | 輸入字元 |
| `[` | `cmpb $0, (%ecx)` + `je` | 條件跳轉（為 0 跳出） |
| `]` | `cmpb $0, (%ecx)` + `jne` | 條件跳轉（非 0 跳回） |

**關鍵特性**：
- 使用 Linux 系統調用（`int 0x80`），無需 C 標準庫
- 入口點為 `_start`，完全獨立運行
- 靜態分配 30,000 字節記憶體
- 使用 `%ecx` 暫存器作為資料指標

---

## 已完成功能 ✅

- ✅ **Brainfuck 解譯器** - 完整實作，支援所有 8 種指令
- ✅ **x86-32 編譯器** - 使用系統調用，不依賴外部庫
- ✅ **效能優化** - 編譯版本比解譯版本快 4-10 倍
- ✅ **範例程式** - 提供 Hello World、Mandelbrot、Hanoi 等範例

---

## 未來實作 🚀

### 更多平台編譯器
- [ ] **x86-64 編譯器** - 支援 64 位元架構
- [ ] **ARM 編譯器** - 針對 ARM 架構（Raspberry Pi、行動裝置）
- [ ] **RISC-V 編譯器** - 支援開源 RISC-V 指令集
- [ ] **LLVM 後端** - 使用 LLVM IR，支援多平台
- [ ] **WebAssembly 編譯器** - 編譯為 WASM，在瀏覽器執行

### 編譯器優化
- [ ] **指令合併** - 將連續的 `+++` 優化為 `addb $3`
- [ ] **迴圈展開** - 優化簡單迴圈結構
- [ ] **死代碼消除** - 移除無效指令
- [ ] **暫存器分配** - 更有效利用 CPU 暫存器

### 其他增強功能
- [ ] **除錯模式** - 顯示執行過程與記憶體狀態
- [ ] **語法檢查** - 編譯前檢查括號配對
- [ ] **互動式 REPL** - 即時輸入與執行指令
- [ ] **JIT 編譯器** - 即時編譯提升解譯效能

---

## 系統需求


- **編譯器**：GCC with multilib support
  ```bash
  sudo apt-get install gcc-multilib
  ```
- **架構**：x86 或 x86-64（編譯器生成 32 位元代碼）


---

**最後更新**：2025-10-23


